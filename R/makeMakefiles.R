#' Create fetch.make, etc. from the information in viz.yaml
#' 
#' Uses information in the corresponding block of viz.yaml to create the 
#' makefiles
#' 
#' @param blocks character vector of names of blocks in the viz.yaml for which
#'   to make makefiles
#'   
#' @export
makeMakefiles <- function(blocks=c('fetch','process','visualize')) {
  makefiles <- lapply(blocks, function(block) {
    makefile <- paste(
      paste0('# Makefile for ', block, ' phase of analysis\n# Do not edit (autogenerated from viz.yaml)'),
      makeMakeMacros(),
      makeMakeRules(block),
      sep='\n\n')
    makeMakeDirs(makefile)
    writeLines(makefile, con=paste0('vizlab/make/', block, '.make'))
    makefile
  })
  lapply(makefiles, cat)
  invisible(makefiles)
}

#' Create the macros section
#' 
#' Create a character string defining the macros to include in every makefile
#' 
#' @export
makeMakeMacros <- function() {
  # read user settings from profile.yaml
  profile <- getProfileInfo()
  userlib <- profile$R_LIBS_USER
  # libs <- if(!is.null(userlib)) {
  #   usequotes <- TRUE# grepl(' ', userlib)
  #   paste0('RLIBSUSER=', if(usequotes) '"', userlib, if(usequotes) '"') 
  # } else c()
  
  # write the macros
  macros <- c(
    #paste0(c('RARGS=--no-save --no-restore --slave', libs), collapse=' '),
    paste0('RLIBSUSER=', if(!is.null(profile$R_LIBS_USER)) paste0('"', profile$R_LIBS_USER, '"') else '$(R_LIBS_USER)'),
    paste0('RARGS=--quiet --no-save --no-restore'), # R_LIBS_USER="',profile$R_LIBS_USER,'"
    paste0('RBATCH="', profile$R, '" CMD BATCH --no-timing $(RARGS)'),
    paste0('REXPR="', profile$R, '" $(RARGS) -e'),
    paste0('RSCRIPT="', profile$RSCRIPT, '" $(RARGS)'))
  
  # combine into a single string
  paste0('# Macros\n\n', paste(macros, collapse='\n'))
}

#' Create directories mentioned in the makefile
#' 
#' Seeks specific directories that are expected to appear in some or all 
#' visualization projects. Creates those for which the makefile indicates a need
#' 
#' @param makefile character string containing the makefile
makeMakeDirs <- function(makefile) {
  # the vizlab/make directory needs to exist so we can put makefiles and other
  # internal documentation there
  if(!dir.exists('vizlab/make')) dir.create('vizlab/make', recursive=TRUE)
  
  # make log directories if specified
  logdirs <- unique(dirname(grep('^vizlab/make/log', strsplit(makefile, '[[:space:]]')[[1]], value=TRUE)))
  if(length(logdirs) > 0) sapply(logdirs, function(logdir) {
    if(!dir.exists(logdir)) dir.create(logdir, recursive=TRUE)
  })
  
  # make cache directories if specified
  cachedirs <- unique(dirname(grep('^cache/', strsplit(makefile, '[[:space:]]')[[1]], value=TRUE)))
  if(length(cachedirs) > 0) sapply(cachedirs, function(cachedir) {
    if(!dir.exists(cachedir)) dir.create(cachedir, recursive=TRUE)
  })
  
  # if any rules use callFunction.R, copy that script into the vizlab/make 
  # directory. this script allows us to call a single function via R CMD BATCH
  if(any(grepl('callFunction.R', makefile))) {
    file.copy(system.file('scripts/callFunction.R', package='vizlab'), 
              './vizlab/make/callFunction.R', overwrite=TRUE)
  }  
}

#' Create the make rules for a block of the viz.yaml
#' 
#' Create the 'all' and specific targets for a makefile for a block of the 
#' viz.yaml
#' 
#' @param block character name of the block for which to create the make rules
#'   
#' @export
makeMakeRules <- function(block=c('fetch','process','visualize')) {
  block <- match.arg(block)
  
  # read information about this block from viz.yaml
  content.info <- getContentInfos(block=block)
  
  # set the 'all' target to include all content items
  all <- makeMakeEmptyRule(
    target='all',
    depends=paste0("\\\n\t", sapply(content.info, `[[`, 'id')))
  
  # write the rules for each content item
  items <- sapply(content.info, function(item.info) {
    makeMakeItem(item.info)
  })
  
  # combine all the targets into a single string
  paste(c(list("# Rules", all), items), collapse='\n\n')
}

#' Make a collection of makefile rules appropriate to a data/figure item
#' 
#' @param item.info viz.yaml item info as from \code{getContentInfo}
#' @param ... other args passed to makeMakeItem methods
#' 
#' @export
makeMakeItem <- function(item.info, ...) UseMethod("makeMakeItem")

#' @rdname makeMakeItem
#' @export
makeMakeItem.default <- function(item.info, ...) {
  class(item.info) <- item.info$block
  makeMakeItem(item.info, ...)
}

#' \code{makeMakeItem.fetch}: Make makefile rules for an item in the fetch block
#' of viz.yaml
#' 
#' @rdname makeMakeItem
#' @importFrom utils methods
#' @export
makeMakeItem.fetch <- function(item.info, ...) {
  
  rules <- list(phony.data=NA, file.data=NA) # data rules will come first but require info on timestamp
  
  # timestamp rules
  needs.timestamp <- {
    lapply(item.info$scripts, source);
    timestamp.methods <- sapply(strsplit(c(methods('fetchTimestamp')), '\\.'), `[`, 2)
    item.info$fetcher %in% timestamp.methods
  }
  if(needs.timestamp) {
    sQuote <- function(x) paste0("'", x, "'")
    timestamp.id <- paste0(item.info$id, '_timestamp')
    timestamp.file <- paste0('vizlab/make/timestamps/', item.info$id, '.txt')
    rules$file.timestamp <- makeMakeEmptyRule(
      target=timestamp.file, 
      depends=timestamp.id)
    rules$phony.timestamp <- makeMakeBatchRule(
      target=timestamp.id,
      fun='fetchTimestamp',
      funargs=c(viz.id=sQuote(item.info$id), outdir=timestamp.file),
      scripts=item.info$scripts,
      logfile=paste0('fetch/', timestamp.id, '.Rout'))
  }
 
  # data rules
  data.file <- item.info$location
  if(grepl(" ", data.file)) data.file <- paste0('"', data.file, '"')
  rules$phony.data <- makeMakeEmptyRule(
    target=item.info$id,
    depends=data.file)
  rules$file.data <- makeMakeBatchRule(
    target=data.file,
    depends=if(needs.timestamp) timestamp.file else c(),
    fun='fetchData',
    funargs=c(viz.id=paste0("'", item.info$id, "'")),
    scripts=item.info$scripts,
    logfile=paste0('fetch/', item.info$id, '.Rout'))
  
  # return
  paste(unlist(unname(rules)), collapse='\n')
}

#' \code{makeMakeItem.process}: Make makefile rules for an item in the
#' process block of viz.yaml
#' 
#' @rdname makeMakeItem
#' @export
makeMakeItem.process <- function(item.info, ...) {
  
  # arg prep
  data.file <- item.info$location
  if(grepl(" ", data.file)) data.file <- paste0('"', data.file, '"')
  dep.files <- sapply(item.info$depends, function(dep) getContentInfo(dep)$location, USE.NAMES=FALSE)
  dep.args <- sapply(item.info$depends, function(dep) paste0("readData('", dep, "')" ))
  
  # data args
  rules <- list()
  rules$phony.data <- makeMakeEmptyRule(
    target=item.info$id,
    depends=data.file)
  rules$file.data <- makeMakeBatchRule(
    target=data.file,
    depends=dep.files,
    fun='processData',
    funargs=c(viz.id=paste0("'", item.info$id, "'"), dep.args, outfile=paste0("'", item.info$location, "'")),
    scripts=item.info$scripts,
    logfile=paste0('process/', item.info$id, '.Rout'))
  
  # return
  paste(unlist(unname(rules)), collapse='\n')
}

#### General makefile-writing functions ####

#' Create text for a make rule that has no commands
#' 
#' The resulting rule will have only a target and maybe dependencies, no
#' commands
#' 
#' @param target character: the target name
#' @param depends character vector: the dependencies
#' @keywords internal
makeMakeEmptyRule <- function(target, depends=c()) {
  depends_chr <- paste(depends, collapse=' ')
  sprintf('%s: %s', target, depends_chr)
}

#' Create text for a make rule using RBATCH
#' 
#' Create the text for a gnu make target that runs a function using R CMD BATCH 
#' and callFunction.R
#' 
#' @param target character: the target name
#' @param depends character vector: the dependencies (omit callFunction.R and 
#'   scripts; these will be automatically added)
#' @param fun character: the function name, to be ultimately evaluated in an 
#'   environment where the scripts have been sourced and library(vizlab) has 
#'   been called. if fun is missing, the command section of the make target
#'   declaration will be omitted
#' @param scripts  character vector: the scripts or script directories to load. 
#'   omit 'scripts' because this will be automatically preprended
#' @param logfile character: the filename where the R CMD BATCH logfile should 
#'   be saved. omit 'vizlab/make/log' because this will be automatically 
#'   prepended
#' @keywords internal
makeMakeBatchRule <- function(target, depends=c(), fun, funargs=c(), scripts=c(), logfile) {
  # R CMD BATCH works fine, but note for future dev: Rscript and littlr can do
  # everything R CMD BATCH can do and are preferred by Dirk Eddelbuettel. See 
  # http://stackoverflow.com/questions/21969145/why-or-when-is-rscript-or-littler-better-than-r-cmd-batch/22358976#22358976,
  # http://stackoverflow.com/questions/14008139/capturing-rscript-errors-in-an-output-file,
  # etc. "To put the output and error in the same file (assuming sh/bash): 
  # RScript --no-save --no-restore --verbose myRfile.R > outputFile.Rout 2>&1"
  
  # modify the arguments to fill in some details
  scripts <- if(length(scripts) > 0) scripts else c()
  depends <- c(depends, scripts)
  
  # convert complex arguments into character strings
  scripts_chr <- paste0("c(", if(length(scripts) > 0) paste0("'", scripts, "'", collapse=', '), ")")
  funargs_chr <- paste0("\\\"list(", if(length(funargs) > 0) paste0(names(funargs), "=", funargs, collapse=", "), "\\\")")
  
  # produce the final character string
  paste(c(
    makeMakeEmptyRule(target, depends),
    sprintf('\texport R_LIBS_USER=$(RLIBSUSER);\\'),
    sprintf('\t${RBATCH} "--args fun=%s funargs=%s scripts=%s" \\', fun, funargs_chr, scripts_chr),#  rlibsuser=%s "'${RLIBSUSER}'"), 
    sprintf('\tvizlab/make/callFunction.R vizlab/make/log/%s', logfile)),
    collapse='\n')
}

#' Create text for a make rule that calls an R expression
#' 
#' The R expression will be called by R.exe -e
#' 
#' @inheritParams makeMakeEmptyRule
#' @param expr character vector of one or more R commands
#' @keywords internal
makeMakeExprRule <- function(target, depends=c(), expr) {
  # produce the final character string
  paste(c(
    makeMakeEmptyRule(target, depends),
    sprintf('\t${REXPR} "%s"', paste0(expr, collapse='; \\\n\t'))),
    collapse='\n')
}
